  .text
  .global longest_inc_subseq

longest_inc_subseq:
    // Сохраняем регистры, которые будем использовать
    sub sp, sp, 16
    stp x29, x30, [sp]
    add x29, sp, 0

    // Входные параметры array, help_array и size хранятся в регистрах x0, x1 и x2 соответственно

    // Проверяем, что размер массивов не равен нулю, чтобы избежать ошибок
    cbz x2, .finish    // если размер равен нулю, заканчиваем обработку
    
    // Создаем переменные для хранения текущего значения LIS и максимального значения LIS
    mov x3, 1     // текущее значение LIS
    mov x4, 1     // максимальное значение LIS
    mov x5, x0    // сохраняем адрес array
    mov x6, x1    // сохраняем адрес help_array
    
    // Начинаем обход массива array
    ldr x7, [x5], 8   // загружаем первый элемент array
    str x3, [x6], 8   // сохраняем начальное значение LIS в help_array
    
.loop:
    cbz x2, .finish    // если размер равен нулю, заканчиваем обработку
    
    ldr x7, [x5], 8   // загружаем текущий элемент array
    
    // Сравниваем текущий элемент с предыдущим
    cmp x7, x4
    ble .next     // если текущий элемент меньше или равен максимальному значению LIS, переходим к следующей итерации
    
    // Если текущий элемент больше максимального значения LIS, находим новое максимальное значение LIS и сохраняем в help_array
    add x3, x3, 1     // увеличиваем текущее значение LIS на 1
    str x3, [x6], 8   // сохраняем текущее значение LIS в help_array
    mov x4, x7        // обновляем максимальное значение LIS
    
.next:
    subs x2, x2, 1     // уменьшаем размер на 1
    b .loop    // переходим к следующей итерации обхода массива
    
.finish:
    // Возвращаем максимальное значение LIS
    ldr x0, [x1]
    
    // Восстанавливаем сохраненные регистры
    ldp x29, x30, [sp]
    add sp, sp, 16
    
    ret
